#+TITLE:    Rapport du projet C++ : Partie 1 & 2
#+AUTHOR:   Gabriel Dos Santos, Raphael Marouani

* Introduction
Le but principal de ce projet est de développer un système de codage et de décodage basé sur le code de Huffmann.
Le codage d’Huffmann a pour but de coder un texte en binaire préfixé qui consiste à coder chaque lettre par un mot sur 0, 1 (toujours le même pour une lettre). Etant donné le pourcentage d’occurrence de chaque lettre dans le texte à coder, l’algorithme de codage des lettres est le suivant :
- Initialement, chaque lettre est un arbre binaire ramené à un sommet étiqueté par la proportion d’occurrences de cette lettre dans le texte. Tant qu’il y a plus d’un arbre, réaliser les opérations suivantes :
  1. Considérer ~A1~ et ~A2~ les deux arbres dont les racines portent les plus petites étiquettes ~e1~ et ~e2~.
  2. Construire un nouvel arbre ~A~ dont la racine ~r~ a pour fils les racines de ~A1~ et ~A2~.
  3. La racine ~r~ est étiqueté par ~e1 + e2~.
- Pour chaque noeud de l’arbre final, l’arrête vers son fils gauche est étiquetée 0 et celle vers son fils droit 1.
- Le code associé à une lettre est le mot binaire composé des étiquettes sur les arrêtes entre la racine de l’arbre final et la feuille étiquetée avec cette lettre.

L'algorithme de Huffman etant avant tout un algorithme de compression de donnees, les mots "encryption" et "compression", ainsi que tous leurs derives grammaticaux, pourront etre utilises de facon interchangeable dans la suite de ce rapport.


* Utilisation de l'application
** Contenu de l'archive du projet
L'archive que vous avez recu contient les fichiers suivants :
- Le rapport du projet ~compte_rendu.pdf~, que vous etes en train de lire.
- Le fichier ~README.md~, qui resume le projet et explique rapidement comment utiliser l'application.
- Le fichier ~listing.pdf~, qui est la documentation complete du projet (partie 1 et 2).
- Les fichiers executables ~build.sh~ et ~.check_dependencies.sh~ pour verifier la presence des dependances necessaires au projet et simplifier le processus de compilation avec CMake.
- Le fichier ~CMakeLists.txt~, qui contient la configuration de l'outil CMake pour creer le Makefile qui compilera l'application.
- Le dossier ~src~, qui contient les fichiers sources du projet. Celui-ci est divise en trois sous-dossiers :
  - ~bin~, qui contient les fichiers ~main1.cpp~ et ~main2.cpp~, les programmes de test.
  - ~lib~, qui contient les fichiers (~*.cpp~) des classes ~Sommet~, ~ArbreB~, ~Part1~ et ~AppWindow~ ainsi que le fichier des fonctions necessaires a la partie 2, ~Part2~.
  - ~headers~, qui contient les fichiers headers (~*.hpp~) pour chacun des fichiers du dossiers ~lib~.

** Configuration requise
Afin de pouvoir utiliser ce programme vous aurez besoin des outils suivants :
- Le compilateur ~gcc~ (version 7.5.0 ou superieure). Alternativement, vous pouvez utiliser le compilateur ~clang++~ (testee avec la version 9.0.0 uniquement).
- Le standard C++ 17 (le minimum requis est le standard C++ 11 mais il est preferable de compiler avec C++ 17).
- L'outil de compilatiion ~cmake~ (version 3.1 ou superieure).
- L'outil pour la realisation d'interface graphique Qt (version 5).


** Compilation et execution
Ce projet utilisant l'outil CMake, le script ~build.sh~ vous est fourni avec l'archive du projet afin de simpilifier les etapes de compilation. Ce script vous permettra egalement de verifier si vous avez les paquets necessaires et vous proposera d'installer les eventuelles dependences manquantes.

Pour compiler le projet, il vous suffit de taper la commande suivante :
#+BEGIN_SRC sh
./build.sh
#+END_SRC

Il vous suffit de suivre les instructions afichees dans le terminal afin de compiler le projet.

Dans le cas ou le script ~build.sh~ n'aurait pas les droits pour etre executable, utilisez la commande suivante avant de relancer le script :
#+BEGIN_SRC sh
chmod +x build.sh .check_dependencies.sh
#+END_SRC

Une fois le projet compile, il vous suffit de l'executer en tapant :
#+BEGIN_SRC sh
./partie_2
#+END_SRC


* Partie 1
** Repartition du travail
Nous avions initialement prevu de travailler de maniere equitable sur l'ensemble de la partie 1 du projet. Le but etait que chacun implemente une partie des classes et des fonctionnalitees demandees dans l'enonce, afin que chaque membre du binome comprenne les choix d'implementation et la facon dont est ecrit le programme.

Devant le manque de reponses et de retours de Raphael, Gabriel a finalement realiser l'integralite de l'implementation des classes ~Sommet~, ~ArbreB~, ~PartOneTests~ ainsi que le programme de test ~main1.cpp~. La redaction de la documentation et des commentaires dans le code source, du README et d'une partie de ce rapport ont egalement ete realisees par Gabriel.
Raphael s'est charge de l'interface graphique et a redige les parties qui y correspondent dans ce compte-rendu.

** Description des classes
*** Classe Sommet
La classe ~Sommet~ represente un noeud d'un arbre binaire.
Par choix d'implementation et pour faciliter les parties suivantes du projet, la classe ~Sommet~ contient deja des attributs pour stocker un caractere et sa frequence. Chaque instance de cette classe contient egalement deux pointeurs, qui permettent une implementation similaire a une liste chainee.
Les attributs de la classe sont les suivants :
- ~char m_Data~ : le caractere affecte au Sommet.
- ~double m_Freq~ : la frequence du caractere affecte au Sommet. L'enonce demandant que la frequence soit represente par un pourcentage, la frequence est representee avec un flottant a double precision.
- ~Sommet* m_Left~ : le fils gauche affecte au Sommet. C'est un pointeur vers un autre Sommet.
- ~Sommet* m_Right~ : le fils droit affecte au Sommet. C'est un egalement un pointeur vers un autre Sommet.

*** Classe ArbreB
La classe ~ArbreB~ represente un arbre binaire.
Elle ne possede qu'un seul attribut, un pointeur sur la racine de cet arbre :
- ~Sommet* m_Root~ : la racine de l'arbre, depuis laquelle on peut acceder a tous les sommets qui le compose grace a l'implementation en liste chainee de la classe ~Sommet~.

*** Classe PartOneTests
La classe ~PartOneTests~ ne sert qu'a implementer des tests qui valident ou non les fonctionnalites des classes ~Sommet~ et ~ArbreB~. Les methodes qui y sont implementees sont utilisees dans le programme de test afin de tester de maniere precises.
Elle possede des attributs qui ne servent qu'a suivre l'etat des tests :
- ~static unsigned int total_tests~ : le nombre total de tests qui ont ete ecrit , ce qui permet de determiner si des tests n'ont pas ete executes (/skipped/).
- ~unsigned int tests_run~ : le nombre de tests qui ont ete executes.
- ~unsigned int tests_failed~ : le nombre de tests qui ont echoues.

** Interface en ligne de commande
Pour l'interface en ligne de commande, Gabriel a ecrit un programme de test (~src/bin/main1.cpp~) qui utilise les methodes de la classe de test ~PartOneTests~. Le but etait de decomposer chaque fonctionnalite des classes de facon a pouvoir les tester le plus precisement possible. L'ordre dans lequel les tests sont executes est egalement logique, les tests plus avances s'appuient sur des fonctionnalites precedemment validees.
L'affichage dans le terminal est inspire de bibliotheque de tests unitaires telle que JUnit (pour le Java).
#+CAPTION:  Voici ce que vous devriez obtenir dans le terminal en tapant la commande 'make run' a la racine du projet.
#+NAME:     fig:cli_output
[[./.screenshot/cli_output.png]]

** Interface graphique
/A faire par Raphael/


* Partie 2
** Ajouts et modifications sur la partie 1
Pour la realisation de la partie 2, nous avons du modifier certains aspects des classes ecrites dans la partie 1 :
- La classe ~PartOneTests~ a ete renomme en ~Part1~ pour harmoniser les noms de fichiers entre la partie 1 et la partie 2.
- Les attributs ~m_Left~ et ~m_Right~ de la classe ~Sommet~ ont ete rendu prives, de meme pour l'attribut ~m_Root~ de la classe ~ArbreB~. Les accesseurs pour ces attributs ont egalement ete implementes.
- Les noms de methodes des accesseurs et des mutateurs ont ete modifies pour etre plus lisible dans le code.
- Les constructeurs par recopie des classes ~Sommet~ et ~ArbreB~ initialisent desormais leurs attributs qui sont des pointeurs a ~nullptr~ grace a la liste d'initialisation. Ceci permet d'eviter des fuites de memoires qui apparaissaient dans certains cas bien particuliers. Afin de prendre en compte ce changement, la surcharge de l'operateur "+" et le destructeur de chacune des classes ont egalement ete modifies.
- La methode ~print()~ qui affiche l'arbre binaire dans le terminal a ete completee par Raphael (l'affichage final a ete legerement modifie par Gabriel pour la partie 2).

** Repartition du travail
Pour la partie 2 du projet, Raphael a corrige le travail sur l'affichage qu'il avait realise pour la partie en ligne de commande. Il a aussi essaye de poursuivre la realisation de l'arbre dans l'interface graphique avec Qt.
Gabriel a quant a lui ecrit l'integralite des fonctions et methodes des fichiers ~Part2.hpp~, ~Part2.cpp~ et la classe ~AppWindow~ (qui gere l'interface graphique avec Qt). Il a egalement ecrit les scripts ~build.sh~ et ~.check_dependencies.sh~, le fichier ~CMakeLists.txt~ ainsi que la documentation et le compte-rendu relatif a la partie 2 du projet.

** Travail realise
*** Fonctions implementees dans le fichier ~Part2.cpp~
Afin de repondre a l'enonce de la partie 2, Gabriel a implemente les differentes fonctions qui permettent de recuperer un texte, calculer les occurences de chaque caracteres qui y sont presents et en construire l'arbre binaire qui y est associe en suivant l'algorithme de Huffman.

Dans le cas ou l'utilisateur souhaiterait recuperer le texte a encrypter depuis un fichier, il peut se servir de la fonction ~parse_file_to_string()~ qui prend en argument le nom d'un fichier et renvoie une chaine de caractere ~std::string~ avec le contenu du fichier.

Afin de creer l'arbre de Huffman pour le texte a encrypter, nous avons choisi de d'abord construire un tableau dynamique ~std::vector~ d'ArbreB. Pour cela, on utilise la fonction ~build_btree~vector()~ qui prend en argument une chaine de caractere ~std::string~ (a noter que l'utilisateur peut ainsi donner directement une chaine de caractere a encrypter plutot qu'un fichier).
Chaque caractere present dans la chaine, ainsi que son occurrence, est represente par un ArbreB dans le tableau.
Cette fonction est relativement simple : on parcourt la chaine et pour chaque caractere lu, on regarde dans le tableau s'il existe deja un ArbreB pour celui-ci (a l'aide de la fonction ~find()~). Si c'est le cas, on augmente l'occurence de 1. Si ce n'est pas le cas, on construit un nouvel ArbreB avec le caractere lu et une occurrence de 1, puis on l'ajoute au tableau.
Apres avoir lu l'integralite de la chaine, on transforme simplement l'occurrence de chaque ArbreB du tableau en pourcentage afin de repondre a l'enonce (cette etape n'etant pas necessaire pour la suite, elle peut etre omise pour des raisons de performance).
Proceder de cette facon nous permet de simplifier l'etape suivante, qui est la construction de l'arbre de Huffman.

Nous construisons ensuite l'arbre de Huffman en suivant l'algorithme du meme nom grace a la fonction ~build_huffman_tree()~. Tant que la taille du tableau construit a l'etape precedente est superieure a 1 :
- On recupere dans le tableau les deux ArbreB ayant le plus petit pourcentage d'occurrence grace a la fonction ~find_lowest()~.
- On fusionne ces deux ArbreB ensemble grace a la surcharge de l'operateur "+" implementee dans la partie 1
- On ajoute au tableau le resulat de cette fusion.
La fonction ~find_lowest()~ prend en argument une reference du tableau et le parcourt. Elle garde en memoire l'indice de l'ArbreB avec la plus petite occurrence, en cree une copie qui sera ensuite renvoyee a ~build_huffman_tree()~ et efface l'original du tableau.
Ici, il est important de noter que c'est une reference du tableau qui doit etre passer a ~find_lowest()~. Sans cela, on supprimerait l'ArbreB sur une copie du tableau et on aurait ainsi une boucle infinie dans ~build_huffman_tree()~ qui causerait un stack overflow.
Pour des raisons d'optimisation des performances et afin d'eviter des copies inutiles, on fusionne directement le resultat des appels a ~find_lowest()~. De meme, on utilise la methode ~emplace_back()~ plutot que ~push_back()~ sur le ~std::vector~ afin de construire l'ArbreB resultant de la fusion directement dans le tableau plutot que de devoir l'y copier.

La derniere etape est d'encrypter en binaire la chaine de caractere de depart. Pour cela, on se sert de la fonction ~compress_to_bin()~ qui prend en argument la ~std::string~ de depart ainsi qu'une ~std::map~ (initialise grace une methode de la classe ArbreB decrite dans la section suivante), et renvoie une ~std::string~ contenant la version encryptee de la chaine de depart.

Les fonctions ~print_input()~, ~print_output()~ et ~print_map()~ sont de simples fonctions d'affichage dans le terminal que nous jugeront inutiles de detailler ici.

*** Methodes implementees dans la classe ArbreB
Pour faciliter l'encryption de la chaine de caractere, Gabriel a implemente la methode publique ~build_huffman_map()~ qui renvoie une ~std::map~ contenant des caracteres en cle en une chaine en valeur. Cette methode initialise la map ainsi qu'une ~std::string~ vide, puis appelle recursivement la methde privee ~map_to_char_code()~ qui effectue un parcours infixe de l'arbre de Huffman.

On ajoutera un "0" a la chaine de caractere a chaque fois que l'on prendra une branche gauche dans l'arbre, et un "1" a chaque fois que l'on prend une branche droite. Lorsque l'on arrive sur une feuille de l'arbre, on ajoute a la map le caractere contenu dans la feuille et la chaine de caracter courante qui nous donne l'encodage pour ce caractere. Enfin, a chaque fois que l'on remonte dans les appels recursifs, on effectue un ~pop_back()~ sur la ~std::string~ afin d'actualiser celle-ci selon notre position dans l'arbre.

*** Implementation de la class AppWindow pour l'interface graphique avec Qt
Etant donne que nous n'avions pas d'interface graphique fonctionnelle pour la partie 1, nous avons du en realiser une pour la partie 2. Gabriel a donc implementee celle-ci avec Qt et la classe ~AppWindow~.

Cette derniere herite de la classe ~QWidget~. Les differents elements qui la compose sont :
- Un ~QGridLayout~ global qui regroupe les elements suivants :
  - Un ~QGridLayout~ qui regroupe les elements relatifs au menu. Ces derniers sont :
    - Un ~QPushButton~ pour compresser un texte.
    - Un ~QPushButton~ pour effacer les champs.
    - Un ~QPushButton~ pour quitter l'application.
  - Un ~QGridLayout~ qui regroupe les elements relatifs au texte. Ces derniers sont :
    - Une ~QTextEdit~ dans laquelle l'utilisateur pourra taper le texte qu'il souhaite encrypter. Vous pouvez egalement directement y coller du texte plutot que de le taper.
    - Une ~QTextEdit~ dans laquelle le texte encrypte en binaire apparaitra. L'utilisateur ne peut pas interagir avec le texte qui s'affichera dans cette "text box".

#+CAPTION:  Voici la fenetre Qt qui vous sera affichee a l'execution du programme.
#+NAME:     fig:qt_window.png
[[./.screenshot/qt_window.png]]

La classe ~AppWindow~ implemente egalement deux methodes qui sont appelees lorsque l'utilisateur clique sur un bouton :
- ~run_compression()~ lorsque l'utilisateur clique sur "Compress". Cette fonction recupere le texte a compresser, cree le tableau d'ArbreB associe, construit l'arbre de Huffman pour le texte en entree, remplie la map pour obtenir le code de chaque caractere, initialise la chaine contenant la version encryptee du texte et enfin l'affiche a l'ecran. L'arbre de Huffman ainsi que l'encodage de chaque caractere s'affiche egalement dans le terminal.
- ~clear_text()~ lorsque l'utilisateur clique sur "Clear". Cette fonction efface le texte precedemment entre par l'utilisateur, ainsi que sa version binaire si l'utilisateur l'a encrypter. A noter que cette fonction n'est pas absolument pas necessaire au bon fonctionnement de l'application et que l'utilisateur peut effacer manuellement le texte qu'il a ecrit.

#+CAPTION:  Un exemple de compression d'une chaine de charactere en binaire avec Qt et l'affichage de l'arbre et de l'encodage de chaque caractere dans le terminal.
#+NAME:     fig:qt_output.png
[[./.screenshot/qt_output.png]]
