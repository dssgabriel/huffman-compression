#+TITLE:    Rapport du projet C++ : Partie 1 & 2
#+AUTHOR:   Gabriel Dos Santos, Raphael Marouani

* Introduction
Le but principal de ce projet est de développer un système de codage et de décodage basé sur le code de Huffmann.
Le codage d’Huffmann a pour but de coder un texte en binaire préfixé qui consiste à coder chaque lettre par un mot sur 0, 1 (toujours le même pour une lettre). Etant donné le pourcentage d’occurrence de chaque lettre dans le texte à coder, l’algorithme de codage des lettres est le suivant :
- Initialement, chaque lettre est un arbre binaire ramené à un sommet étiqueté par la proportion d’occurrences de cette lettre dans le texte. Tant qu’il y a plus d’un arbre, réaliser les opérations suivantes :
  1. Considérer ~A1~ et ~A2~ les deux arbres dont les racines portent les plus petites étiquettes ~e1~ et ~e2~.
  2. Construire un nouvel arbre ~A~ dont la racine ~r~ a pour fils les racines de ~A1~ et ~A2~.
  3. La racine ~r~ est étiqueté par ~e1 + e2~.
- Pour chaque noeud de l’arbre final, l’arrête vers son fils gauche est étiquetée 0 et celle vers son fils droit 1.
- Le code associé à une lettre est le mot binaire composé des étiquettes sur les arrêtes entre la racine de l’arbre final et la feuille étiquetée avec cette lettre.

* Utilisation de l'application
** Contenu de l'archive du projet
L'archive que vous avez recu contient les fichiers suivants :
- Le rapport du projet ~compte_rendu.pdf~, que vous etes en train de lire.
- Le fichier ~README.md~, qui resume le projet et explique rapidement comment utiliser l'application.
- Le fichier ~listing.pdf~, qui est la documentation complete du projet (partie 1 et 2).
- Les fichiers executables ~build.sh~ et ~.check_dependencies.sh~ pour verifier la presence des dependances necessaires au projet et simplifier le processus de compilation avec CMake.
- Le fichier ~CMakeLists.txt~, qui contient la configuration de l'outil CMake pour creer le Makefile qui compilera l'application.
- Le dossier ~src~, qui contient les fichiers sources du projet. Celui-ci est divise en trois sous-dossiers :
  - ~bin~, qui contient les fichiers ~main1.cpp~ et ~main2.cpp~, les programmes de test.
  - ~lib~, qui contient les fichiers (~*.cpp~) des classes ~Sommet~, ~ArbreB~, ~Part1~ et ~AppWindow~ ainsi que le fichier des fonctions necessaires a la partie 2, ~Part2~.
  - ~headers~, qui contient les fichiers headers (~*.hpp~) pour chacun des fichiers du dossiers ~lib~.

** Configuration requise
Afin de pouvoir utiliser ce programme vous aurez besoin des outils suivants :
- Le compilateur ~gcc~ (version 7.5.0 ou superieure). Alternativement, vous pouvez utiliser le compilateur ~clang++~ (testee avec la version 9.0.0 uniquement).
- Le standard C++ 17 (le minimum requis est le standard C++ 11 mais il est preferable de compiler avec C++ 17).
- L'outil de compilatiion ~cmake~ (version 3.1 ou superieure).
- L'outil pour la realisation d'interface graphique Qt (version 5).


** Compilation et execution
Ce projet utilisant l'outil CMake, le script ~build.sh~ vous est fourni avec l'archive du projet afin de simpilifier les etapes de compilation. Ce script vous permettra egalement de verifier si vous avez les paquets necessaires et vous proposera d'installer les eventuelles dependences manquantes.

Pour compiler le projet, il vous suffit de taper la commande suivante :
#+BEGIN_SRC sh
./build.sh
#+END_SRC

Il vous suffit de suivre les instructions afichees dans le terminal afin de compiler le projet.

Dans le cas ou le script ~build.sh~ n'aurait pas les droits pour etre executable, utilisez la commande suivante avant de relancer le script :
#+BEGIN_SRC sh
chmod +x build.sh .check_dependencies.sh
#+END_SRC

Une fois le projet compile, il vous suffit de l'executer en tapant :
#+BEGIN_SRC sh
./partie_2
#+END_SRC


* Partie 1
** Repartition du travail
Nous avions initialement prevu de travailler de maniere equitable sur l'ensemble de la partie 1 du projet. Le but etait que chacun implemente une partie des classes et des fonctionnalitees demandees dans l'enonce, afin que chaque membre du binome comprenne les choix d'implementation et la facon dont est ecrit le programme.

Devant le manque de reponses et de retours de Raphael, Gabriel a finalement realiser l'integralite de l'implementation des classes ~Sommet~, ~ArbreB~, ~PartOneTests~ ainsi que le programme de test ~main1.cpp~. La redaction de la documentation et des commentaires dans le code source, du README et d'une partie de ce rapport ont egalement ete realisees par Gabriel.
Raphael s'est charge de l'interface graphique et a redige les parties qui y correspondent dans ce compte-rendu.

** Description des classes
*** Classe Sommet
La classe ~Sommet~ represente un noeud d'un arbre binaire.
Par choix d'implementation et pour faciliter les parties suivantes du projet, la classe ~Sommet~ contient deja des attributs pour stocker un caractere et sa frequence. Chaque instance de cette classe contient egalement deux pointeurs, qui permettent une implementation similaire a une liste chainee.
Les attributs de la classe sont les suivants :
- ~char m_Data~ : le caractere affecte au Sommet.
- ~double m_Freq~ : la frequence du caractere affecte au Sommet. L'enonce demandant que la frequence soit represente par un pourcentage, la frequence est representee avec un flottant a double precision.
- ~Sommet* m_Left~ : le fils gauche affecte au Sommet. C'est un pointeur vers un autre Sommet.
- ~Sommet* m_Right~ : le fils droit affecte au Sommet. C'est un egalement un pointeur vers un autre Sommet.

*** Classe ArbreB
La classe ~ArbreB~ represente un arbre binaire.
Elle ne possede qu'un seul attribut, un pointeur sur la racine de cet arbre :
- ~Sommet* m_Root~ : la racine de l'arbre, depuis laquelle on peut acceder a tous les sommets qui le compose grace a l'implementation en liste chainee de la classe ~Sommet~.

*** Classe PartOneTests
La classe ~PartOneTests~ ne sert qu'a implementer des tests qui valident ou non les fonctionnalites des classes ~Sommet~ et ~ArbreB~. Les methodes qui y sont implementees sont utilisees dans le programme de test afin de tester de maniere precises.
Elle possede des attributs qui ne servent qu'a suivre l'etat des tests :
- ~static unsigned int total_tests~ : le nombre total de tests qui ont ete ecrit , ce qui permet de determiner si des tests n'ont pas ete executes (/skipped/).
- ~unsigned int tests_run~ : le nombre de tests qui ont ete executes.
- ~unsigned int tests_failed~ : le nombre de tests qui ont echoues.

** Interface en ligne de commande
Pour l'interface en ligne de commande, Gabriel a ecrit un programme de test (~src/bin/main1.cpp~) qui utilise les methodes de la classe de test ~PartOneTests~. Le but etait de decomposer chaque fonctionnalite des classes de facon a pouvoir les tester le plus precisement possible. L'ordre dans lequel les tests sont executes est egalement logique, les tests plus avances s'appuient sur des fonctionnalites precedemment validees.
L'affichage dans le terminal est inspire de bibliotheque de tests unitaires telle que JUnit (pour le Java).
#+CAPTION:  Voici ce que vous devriez obtenir dans le terminal en tapant la commande 'make run' a la racine du projet.
#+NAME:     fig:cli_output
[[./.screenshot/cli_output.png]]

** Interface graphique
/A faire par Raphael/

* Partie 2
** Ajouts/Modifications sur la partie 1
Pour la realisation de la partie 2, nous avons modifie certaines choses dans les classes ecrites dans la partie 1 :
- La classe ~PartOneTests~ a ete renomme en ~Part1~ pour harmoniser les noms de fichiers entre la partie 1 et la partie 2.
- Les attributs ~m_Left~ et ~m_Right~ de la classe ~Sommet~ ont ete rendu prive, de meme pour l'attribut ~m_Root~ de la classe ~ArbreB~. Les accesseurs pour ces attributs ont egalement ete reecrit.
- Les noms des methodes des accesseurs et des mutateurs ont ete modifies pour etre plus simple et lisible dans le code.
- Les constructeurs par recopie des classes ~Sommet~ et ~ArbreB~ initialisent desormais leurs attributs qui sont des pointeurs a ~nullptr~ avec la liste d'initialisation. Ceci permet d'eviter des fuites de memoires qui apparaissaient dans certains cas bien particuliers. Afin de prendre en compte ce changement, la surcharge de l'operateur "+" et le destructeur de chacune des classes ont egalement ete modifie.
- La methode ~print()~ qui affiche l'arbre binaire dans le terminal a ete complete par Raphael (l'affichage final a ete legerement modifie par Gabriel pour la partie 2).

** Repartition du travail
Pour la partie 2 du projet, Raphael a corrige le travail qu'il a realise pour la partie en ligne de commande. Il a aussi essaye de poursuivre la realisation de l'affichage de l'arbre dans l'interface graphique avec Qt.
Gabriel a quant a lui ecrit l'integralite des fonctions necessaires a l'implementation de la partie 2, ainsi que la classe ~AppWindow~ qui gere l'interface graphique avec Qt. Il a egalement ecrit les scripts ~build.sh~ et ~.check_dependencies.sh~, le fichier ~CMakeLists.txt~ et la documentation relative a la partie 2 du projet.

** Description des fonctions


** Realisation de l'interface graphique
